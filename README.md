# **Project Overview**
## Purpose of the Project
***Project R*** is a 2D game developed with Unity, designed specifically for UBC Life Sciences Centre. Players control a spaceship in the game by wearing hand-tracking devices, collecting flying asteroids to earn points. The game evaluates player performance through scoring and provides continuous progress feedback, aiming to combine entertainment with hand coordination training.
## Basic Setup Instructions
### 1. Clone the Repository
First, clone the project repository to your local machine. Go to a proper root directory, open a terminal or command-line tool and run the following command:
```console
git clone -b 1.1 https://github.com/Shyen-Yi/HIVE-Rehab-Project.git
```
where **1.1** is the branch for the latest version (in **Feb., 2025**)
### 2. Install Unity Version
Ensure that **Unity 2022.3.4f1** is installed in your development environment. If not, download and install the correct version from the [Unity Hub](https://unity.com/download).
### 3. Open the Project
1. Open Unity Hub.
2. Go to the **Projects** tab and click **Add**.
3. Navigate to the cloned repository directory (`HIVE-Rehab-Project`), select the project folder, and click **Open**.
4. Make sure Unity Hub opens the project using **Unity 2022.3.4f1**.
### 4. Set the Bootstrapper Scene
In the Unity Editor:
1. Open the **Scenes** folder.
2. Locate and double-click the `Bootstrapper` scene to ensure it is the only open scene.
3. In the Unity Editor, go to **File** > **Build Settings**.
4. Confirm that the `Bootstrapper` scene is added to the **Scenes in Build** list and is the first scene.
### 5. Run the Game
1. Click the **Play** button at the top of the Unity Editor.
2. Ensure that the hand-tracking device (Leap Motion) is properly connected and configured.
3. Once the game starts, players can control the cursor with the hand-tracking device (or W-A-S-D/Up-Left-Down-Right on the keyboard) and interact with the game using the device and keyboard.
### 6. Notes
- If Unity prompts for missing dependencies, install the required packages via the **Package Manager**.
- Ensure that the **drivers and SDK** for the hand-tracking device (Leap Motion) are properly installed and configured.
- If you encounter any issues, refer to the project’s `README.md` file or submit an Issue on the GitHub repository.

# **Project Organization**
## Folder Structure
#### `Assets` Folder
The `Assets` folder contains all the resources, scripts, and data used in the game. This is the primary directory where all the game assets are stored.
- **`AddressableAssetsData`**: Contains data related to addressable assets, allowing efficient asset management and memory usage optimization.
- **`Art`**: Holds all art-related resources, including colors, fonts, materials, shaders, and sprites. These are essential visual assets used throughout the game.
    - **`Colors`**: Stores color preset configurations, which are used for visual styling across the game.
    - **`Fonts`**: Contains font assets for text rendering.
    - **`Materials`**: Includes material files that define the appearance of game objects.
    - **`Shaders`**: Holds custom shaders used to manipulate the rendering process.
    - **`Sprites`**: Contains sprite assets used for 2D objects, characters, and UI elements.
- **`Audio`**: Manages all audio files and associated resources.
    - **`AudioFiles`**: Contains the raw audio files used for background music, sound effects, etc.
    - **`Resources`**: Stores audio-related resources, such as audio mixers.
        - **`AudioMixers`**: Includes audio mixer assets for balancing and mixing audio during runtime.
- **`CSVFiles`**: Houses CSV files that contain data generated by players when gaming.
- **`Plugins`**: This folder includes third-party or custom plugins that extend the functionality of Unity, like `DOTween`, `CsvHelper`. These provide additional utilities for animation and data handling.
- **`Prefabs`**: Contains reusable prefab objects, which are game objects with pre-configured components. The prefabs are organized into:
    - **`Common`**: Prefabs shared across multiple scenes.
    - **`Scenes`**: Prefabs specific to individual scenes.
- **`Resources`**: A folder to store game assets that can be loaded dynamically at runtime, such as configuration files and scene-specific data.
    - **`Config`**: Holds various configuration data files, such as calibration settings, game settings, input configurations, and sound settings.
- **`Scenes`**: Contains all the Unity scene files. Each scene represents a different part of the game, such as menus, gameplay areas, and transitions.
    - Examples include **`MainMenu`**, **`Pause`**, **`CoreGame`**, and **`Calibration`** scenes.
- **`Scripts`**: Contains the game’s logic and scripts organized into various categories:
    - **`Config`**: Holds scripts that manage configuration-related logic and data.
    - **`Core`**: Contains essential scripts that manage game logic, state transitions, and other core systems.
    - **`Editor`**: Contains custom editor scripts that extend Unity’s editor functionality.
    - **`Game`**: Manages gameplay-specific logic, such as scene controllers, level management, and gameplay systems.
    - **`Util`**: Houses utility scripts for general-purpose functions, like helper methods and data processing.
- **`Settings`**: Stores configuration settings that affect the game’s behavior in the Unity editor, including quality settings, input settings, and other preferences.
- **`TextMesh Pro`**: This folder contains assets related to TextMesh Pro, which is used for rendering advanced text in Unity.
- **`UI Toolkit`**: Contains assets and resources for UI design and development, specifically for Unity's UI Toolkit.
- **`XR`**: Contains resources and assets related to XR (Extended Reality), including VR and AR-related content.
## Key Components
#### `GameManager`
The **`GameManager`** is a central component in the game, responsible for managing the overall game flow and synchronizing various core systems. It serves as the main controller for initializing and coordinating different modules, such as scene management, input, camera control, and game state transitions. The `GameManager` ensures that the game runs smoothly and maintains consistency across all gameplay systems.
#### 1. Managers
- **`CameraManager`**:
    - **Purpose**: Manages the main camera in the game, ensuring it properly handles different camera views and interactions.
    - **Responsibility**: Controls the camera stack, adjusts the camera for different scenes, and manages the camera's position, rotation, and other settings based on the scene's needs.
    - **Usage**: Often used to manage the camera for different game scenes (e.g., main game scenes, UI scenes) by adjusting the camera's settings based on the active scene.
- **`SoundManager`**:
    - **Purpose**: Manages all aspects of audio in the game, including background music, sound effects, and audio mixers.
    - **Responsibility**: Plays sounds, adjusts volumes, and controls the background music. Also manages transitions between different audio tracks or sound effects.
    - **Usage**: Used in multiple scenes to control music, sound effects, and manage the audio environment, ensuring the correct sounds are played at the right time.
- **`InputManager`**:
    - **Purpose**: Handles user input, such as keyboard, mouse, or controller events.
    - **Responsibility**: Collects input from the user and translates it into actions within the game (e.g., moving characters, interacting with UI).
    - **Usage**: Used to capture user input for in-game actions or menu navigation, including actions like showing/hiding the cursor and centering the cursor for specific tasks.
- **`CSVManager`**:
    - **Purpose**: A utility that handles the parsing and management of CSV files used for game configurations or data.
    - **Responsibility**: Reads and writes CSV files containing configuration data for game levels, player stats, or other gameplay-related parameters. This helps centralize game data and allows for easy modifications via CSV files.
    - **Usage**: Used to load game data from CSV files, making it easier to manage large amounts of game-specific data.
- **etc.**
#### 2. Scene Controllers
- **`GameSceneControllerBase`**:
    - **Purpose**: This is the base class for all scene-specific controllers in the game. It handles the lifecycle of a scene, including initialization, visibility (show/hide), and disposal. This class provides methods like `OnInit()`, `OnShow()`, and `OnHide()` that can be overridden in subclasses to implement scene-specific logic.
    - **Responsibility**: Controls the flow of the scene, integrates UI elements, and manages scene transitions.
    - **Usage**: Subclasses of `GameSceneControllerBase` are created for each scene, such as the main menu, calibration scene, and gameplay scenes. These controllers define the behavior for showing, hiding, and managing scene-specific UI and logic.
- **`CalibrationController`**:
    - **Purpose**: A specialized controller for managing the calibration scene, guiding the user through different stages of the calibration process.
    - **Responsibility**: Handles the flow of the calibration process, such as setting up UI elements (e.g., buttons and markers), tracking user input, and updating the calibration status.
    - **Usage**: Controls the calibration stages, processes user interactions, and manages the calibration markers, spacecraft, and UI updates.
- **etc.**
#### 3. Utility Functions
- **`LineDrawer`**:
    - **Purpose**: A utility script for drawing lines in the scene using Unity’s `LineRenderer` component.
    - **Responsibility**: Allows for dynamically drawing lines between specified points, useful for creating paths, ropes, or other visual connections between objects.
    - **Usage**: Used in various gameplay mechanics, such as showing paths, connections between UI elements, or guiding the player through certain areas or actions.
- **`TagNames`**:
    - **Purpose**: A static class that holds a collection of tag names used throughout the game.
    - **Responsibility**: Ensures consistency in how tags are applied to game objects. This is particularly useful for identifying objects based on their role (e.g., camera, player, enemy) without hardcoding strings in various places.
    - **Usage**: Used across the project for object identification, such as when searching for specific objects in the scene (e.g., finding all enemies or checking for specific game components).
- **etc.**
#### 4. ScriptableObjects and Configurations
- **`GameConfigs` (e.g., `CoreGameConfig`, `CalibrationConfig`)**:
    - **Purpose**: ScriptableObjects that store configuration data for various systems in the game, such as general gameplay settings, calibration settings, or level data.
    - **Responsibility**: Provide a way to store game data externally in Unity, allowing designers or developers to modify configurations without directly altering the code.
    - **Usage**: Used by scene controllers or game systems to load and apply the appropriate settings, such as the speed of gameplay, difficulty, or calibration data.

# **How to Extend the Project**
## How to Add a New Scene
#### 1. Create a New Scene:
- **Step 1**: In the **Project View**, navigate to the `Assets/Scenes` directory.
- **Step 2**: Locate the existing **"Template"** scene. This scene serves as a basic structure for new scenes and includes common configurations such as UI setup, camera setup, and scene-specific settings.
- **Step 3**: Right-click on the **"Template"** scene and select **Rename**. Rename the copied scene to **"Example"** (or the appropriate name for your new scene).
- **Step 4**: Open the **File** menu in the Unity editor and go to **Build Settings**. In the **Scenes In Build** section, click **Add Open Scenes** to add the new scene to the build. This ensures that the scene can be loaded during gameplay.
#### 2. Edit the Scene:
- **Step 1**: Double-click on the newly created **"Example"** scene (or drag it into the **Inspector View**) to open it.
- **Step 2**: Under the **Canvas** in the **Hierarchy View**, begin designing your scene’s user interface (UI). This can involve adding buttons, text, images, and other UI elements that are part of your scene.
- **Step 3**: For elements that need to be controlled or referenced by scripts, such as buttons or panels, drag and drop them into the **GeneralSceneConfig** component in the **Root** object of the scene. This allows you to easily manage references to the UI elements in the scene controller script later.
#### 3. Write the Scene Controller Script:
- **Step 1**: In the **Project View**, navigate to the `Assets/Scripts/Game/Scenes` directory.
- **Step 2**: Create a new folder inside the `Scenes` directory, and name it after your scene (e.g., `Example`).
- **Step 3**: Inside the **Example** folder, create a new **C# script** and name it **`ExampleController`** (use the scene name followed by “Controller”).
- **Step 4**: Open the **ExampleController** script in your code editor. This script will serve as the scene controller, handling the logic, lifecycle methods, and interactions for your new scene.
- **Step 5**: In the `ExampleController` script, make sure to inherit from **`GameSceneControllerBase`**, which is the base class for managing scene-specific behavior.
- **Step 6**: Implement the **`OnInit()`**, **`OnShow()`**, and **`OnHide()`** methods to manage the scene's lifecycle, including initializing the scene, showing the UI, and cleaning up resources.
- **Step 7**: Refer to the UI elements from the scene by adding appropriate public variables in the controller class and assigning them in the Unity inspector.
## How to Add a New Config File
#### 1. Open the Config File Generator Tool:
- In Unity's top menu, go to **`Tools` > `Hive Toolkit`**.
- From the dropdown, select **`Config File Generator`** to open the tool window.
#### 2. Input the SO Key:
- In the **SO Key** field, input the name (keyword) for your new configuration file (e.g., **`Example`**).
- Click the **`Check`** button to verify and preview the name of the corresponding ScriptableObject (SO).
#### 3. Add Headers to the Config File:
- In the **Headers** section, click the **`+`** button to add the necessary headers (fields) for your configuration table.
- Specify the **Name**, **Type** (e.g., String, Enum), and **Type Namespace** (e.g., **System** for standard types).
- After defining the headers, click **`Validate`** to check if everything is set up correctly.
#### 4. Generate the Config File Script:
- After validation, click **`Generate`** 
	- An **`ExampleSO.cs`** script will be created in the **`Assets/Scripts/Config/ScriptableObjects`** folder. This script will define the ScriptableObject class for your configuration.
	- An **`ExampleSOEditor.cs`** script will be created in the **`Assets/Scripts/Config/ScriptableObjects/Editor`** folder. This script will define the in-editor behaviors of any instance of ExampleSO in the project for your configuration.
#### 5. Create the ScriptableObject Instance:
- Go to **`Assets/Resources/Config`** in the **Project View**.
- Right-click within the folder and navigate to **Create > ScriptableObject > Config Files**.
- Select the **`ExampleConfig`** (or the name of your new config) to create a ScriptableObject instance.
- You will now have the `ExampleConfig` ScriptableObject in the **Resources/Config** folder.
#### 6. Edit the ScriptableObject:
- Select the newly created **`ExampleConfig`** ScriptableObject in the **Project View**.
- In the **Inspector**, you can now add and delete config items, edit the fields and values defined in the ScriptableObject. The generated **`ExampleSO.cs`** script will handle the data structure and behavior of the config file.

## How to Modify Configuration Data in the Game
#### 1. Locate the Config File:
- All configuration files (e.g., **Core Game Level Config**) are stored in the **`Assets/Resources/Config`** folder within your Unity project.
- Navigate to the **`Assets/Resources/Config`** folder in **Project View**.
#### 2. Select the Config File:
- Find and **select** the **ScriptableObject** configuration file you want to edit (e.g., **`Core Game Level Config`**).
#### 3. Edit the Configuration Data:
- With the selected config file, go to the **Inspector View**.
- You'll see a section labeled **`Items`** where each **Element** represents one row of data in the table.
- Click on the **expand arrow** next to the **Element** to reveal the individual fields (columns) like **Level**, **Asteroid Speed**, **Asteroid Size**, and others.
- **Modify** the values directly in the Inspector. Changes will **take effect immediately** and will be reflected in the game the next time the config file is used.
#### 4. Save Changes:
- Once you've made the necessary edits, Unity automatically saves them when you modify the fields. There's no need to manually save the ScriptableObject file.
#### Example:
- In the **`Core Game Level Config`**, under the **`Items`** section:
    - **Element 0** represents a single configuration set (row) for the game.
    - Each field, such as **Asteroid Speed**, **Asteroid Size**, and **Spacecraft Size**, can be modified by directly changing the values in the Inspector.
#### Effect of Changes:
- The data changes will be reflected instantly when the game is running, allowing for quick adjustments to gameplay mechanics (such as altering asteroid speed or adjusting level requirements).

## How to Update an Existing Config File's Headers
#### 1. Open the Config File Generator Tool:
- In Unity's top menu, navigate to **`Tools` > `Hive Toolkit`**.
- From the dropdown, select **`Config File Generator`** to open the tool window.
#### 2. Input the SO Key:
- In the **SO Key** field, enter the keyword that corresponds to the existing configuration file you want to edit (e.g., **`Debug`**).
- After entering the keyword, click the **`Check`** button.
    - The tool will check if a ScriptableObject already exists for this **SO Key**.
    - If the file exists, a **`Load`** button will appear instead of the **`Check`** button.
#### 3. Load the Existing Config File:
- Click the **`Load`** button. This will load the existing configuration file, and you will see the current header fields (e.g., the existing column names, types, etc.) in the tool.
#### 4. Edit the Config File:
- Modify the table headers (fields) as needed. You can:
    - **Add** new headers by clicking the **`+`** button.
    - **Edit** the existing fields, such as their names or types.
    - **Remove** unnecessary fields by clicking the **`-`** button.
- After making the necessary changes, click **`Validate`** to ensure the configuration is correct.
#### 5. Save the Edited Config File:
- Once you've finished editing, click **`Generate`** to save the changes to the ScriptableObject (SO). The modified file will be saved in the **`Assets/Resources/Config`** directory.

## How to Generate Scripts for Config Files
Once your configuration files (ScriptableObjects) are set up, you will need to generate the corresponding scripts to access the data in the game. These scripts will allow you to easily reference the header fields and the specific content in the configuration file.
#### 1. Open the Config Data Generator Tool:
- In Unity's top menu, go to **`Tools` > `Hive Toolkit`**.
- From the dropdown, select **`Config Data Generator`** to open the tool.
#### 2. Configure the Paths (Only If Necessary):
- The tool will show two fields:
    - **Config ScriptableObject Path**: This is the path where the ScriptableObject configuration files are stored (default: **`Assets/Resources/Config`**).
    - **Config Data Path**: This is the path where the generated script files will be saved (default: **`Assets/Scripts/Config/Data`**).Normally, these paths do not need to be modified, so you can leave them as they are. However, if needed, you can change the paths based on your project structure.
#### 3. Generate the Scripts:
- Click the **`Generate`** button.
    - The tool will automatically generate the following scripts for each of the **ScriptableObject** configuration files in your **Config ScriptableObject Path**:
        - **`ConfigData.cs`**: This script represents the data in your configuration file, and it will be overwritten every time you click **Generate**.
        - **`ConfigDataExtension.cs`**: This script is used to define any special logic or extensions for your configuration file. Unlike the `ConfigData.cs` script, this will **not** be overwritten and will remain persistent.
#### 4. Special Logic in the Extension Script:
- Any custom logic specific to the configuration file should be added in the **`ConfigDataExtension.cs`** file. This allows you to add functionality such as data validation, specific behaviors, or any modifications that might be needed for your game's configuration files.

## How to Delete a Config File and Its Associated Files
To fully remove a configuration file from the project, you need to delete all related files that were generated during the creation of the configuration. Using **"Example"** as an example, here are the steps to delete the files:
#### 1. Delete the Config ScriptableObject:
- Navigate to **`Assets/Resources/Config`**.
- Locate and **delete** the **`ExampleConfig`** file. This is the **ScriptableObject instance** that holds your configuration data.
#### 2. Delete the Generated Data Files:
- Go to **`Assets/Scripts/Config/Data`**.
- Delete the **`ExampleConfigData.cs`** and **`ExampleConfigDataExtension.cs`** files. These are the scripts generated by the **Config Data Generator** that correspond to the **ExampleConfig** ScriptableObject.
#### 3. Delete the Config ScriptableObject Script:
- In **`Assets/Scripts/Config/ScriptableObjects`**, locate and **delete** the **`ExampleSO.cs`** file. This file defines the structure of the **`ExampleConfig`** ScriptableObject.
#### 4. Delete the Editor Script (If Present):
- Navigate to **`Assets/Scripts/Config/ScriptableObjects/Editor`**.
- If there is a corresponding **`ExampleSOEditor.cs`** file, **delete** it. This editor script provides custom editor functionality for **`ExampleSO`** but is not required once the configuration is deleted.